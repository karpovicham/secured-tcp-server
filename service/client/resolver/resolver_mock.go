package resolver

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/karpovicham/secured-tcp-server/internal/proto"
)

// ResolverMock implements Resolver
type ResolverMock struct {
	t minimock.Tester

	funcLogin          func(reqData proto.LoginRequestData) (l1 proto.LoginResponseData, err error)
	inspectFuncLogin   func(reqData proto.LoginRequestData)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mResolverMockLogin

	funcLogout          func(reqData proto.LogoutRequestData) (l1 proto.LoginResponseData, err error)
	inspectFuncLogout   func(reqData proto.LogoutRequestData)
	afterLogoutCounter  uint64
	beforeLogoutCounter uint64
	LogoutMock          mResolverMockLogout
}

// NewResolverMock returns a mock for Resolver
func NewResolverMock(t minimock.Tester) *ResolverMock {
	m := &ResolverMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.LoginMock = mResolverMockLogin{mock: m}
	m.LoginMock.callArgs = []*ResolverMockLoginParams{}

	m.LogoutMock = mResolverMockLogout{mock: m}
	m.LogoutMock.callArgs = []*ResolverMockLogoutParams{}

	return m
}

type mResolverMockLogin struct {
	mock               *ResolverMock
	defaultExpectation *ResolverMockLoginExpectation
	expectations       []*ResolverMockLoginExpectation

	callArgs []*ResolverMockLoginParams
	mutex    sync.RWMutex
}

// ResolverMockLoginExpectation specifies expectation struct of the Resolver.Login
type ResolverMockLoginExpectation struct {
	mock    *ResolverMock
	params  *ResolverMockLoginParams
	results *ResolverMockLoginResults
	Counter uint64
}

// ResolverMockLoginParams contains parameters of the Resolver.Login
type ResolverMockLoginParams struct {
	reqData proto.LoginRequestData
}

// ResolverMockLoginResults contains results of the Resolver.Login
type ResolverMockLoginResults struct {
	l1  proto.LoginResponseData
	err error
}

// Expect sets up expected params for Resolver.Login
func (mmLogin *mResolverMockLogin) Expect(reqData proto.LoginRequestData) *mResolverMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ResolverMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ResolverMockLoginExpectation{}
	}

	mmLogin.defaultExpectation.params = &ResolverMockLoginParams{reqData}
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the Resolver.Login
func (mmLogin *mResolverMockLogin) Inspect(f func(reqData proto.LoginRequestData)) *mResolverMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for ResolverMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by Resolver.Login
func (mmLogin *mResolverMockLogin) Return(l1 proto.LoginResponseData, err error) *ResolverMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ResolverMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ResolverMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &ResolverMockLoginResults{l1, err}
	return mmLogin.mock
}

// Set uses given function f to mock the Resolver.Login method
func (mmLogin *mResolverMockLogin) Set(f func(reqData proto.LoginRequestData) (l1 proto.LoginResponseData, err error)) *ResolverMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the Resolver.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the Resolver.Login method")
	}

	mmLogin.mock.funcLogin = f
	return mmLogin.mock
}

// When sets expectation for the Resolver.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mResolverMockLogin) When(reqData proto.LoginRequestData) *ResolverMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ResolverMock.Login mock is already set by Set")
	}

	expectation := &ResolverMockLoginExpectation{
		mock:   mmLogin.mock,
		params: &ResolverMockLoginParams{reqData},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up Resolver.Login return parameters for the expectation previously defined by the When method
func (e *ResolverMockLoginExpectation) Then(l1 proto.LoginResponseData, err error) *ResolverMock {
	e.results = &ResolverMockLoginResults{l1, err}
	return e.mock
}

// Login implements Resolver
func (mmLogin *ResolverMock) Login(reqData proto.LoginRequestData) (l1 proto.LoginResponseData, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(reqData)
	}

	mm_params := &ResolverMockLoginParams{reqData}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_got := ResolverMockLoginParams{reqData}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("ResolverMock.Login got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the ResolverMock.Login")
		}
		return (*mm_results).l1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(reqData)
	}
	mmLogin.t.Fatalf("Unexpected call to ResolverMock.Login. %v", reqData)
	return
}

// LoginAfterCounter returns a count of finished ResolverMock.Login invocations
func (mmLogin *ResolverMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of ResolverMock.Login invocations
func (mmLogin *ResolverMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to ResolverMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mResolverMockLogin) Calls() []*ResolverMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*ResolverMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *ResolverMock) MinimockLoginDone() bool {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		return false
	}
	return true
}

// MinimockLoginInspect logs each unmet expectation
func (m *ResolverMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ResolverMock.Login with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ResolverMock.Login")
		} else {
			m.t.Errorf("Expected call to ResolverMock.Login with params: %#v", *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && mm_atomic.LoadUint64(&m.afterLoginCounter) < 1 {
		m.t.Error("Expected call to ResolverMock.Login")
	}
}

type mResolverMockLogout struct {
	mock               *ResolverMock
	defaultExpectation *ResolverMockLogoutExpectation
	expectations       []*ResolverMockLogoutExpectation

	callArgs []*ResolverMockLogoutParams
	mutex    sync.RWMutex
}

// ResolverMockLogoutExpectation specifies expectation struct of the Resolver.Logout
type ResolverMockLogoutExpectation struct {
	mock    *ResolverMock
	params  *ResolverMockLogoutParams
	results *ResolverMockLogoutResults
	Counter uint64
}

// ResolverMockLogoutParams contains parameters of the Resolver.Logout
type ResolverMockLogoutParams struct {
	reqData proto.LogoutRequestData
}

// ResolverMockLogoutResults contains results of the Resolver.Logout
type ResolverMockLogoutResults struct {
	l1  proto.LoginResponseData
	err error
}

// Expect sets up expected params for Resolver.Logout
func (mmLogout *mResolverMockLogout) Expect(reqData proto.LogoutRequestData) *mResolverMockLogout {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("ResolverMock.Logout mock is already set by Set")
	}

	if mmLogout.defaultExpectation == nil {
		mmLogout.defaultExpectation = &ResolverMockLogoutExpectation{}
	}

	mmLogout.defaultExpectation.params = &ResolverMockLogoutParams{reqData}
	for _, e := range mmLogout.expectations {
		if minimock.Equal(e.params, mmLogout.defaultExpectation.params) {
			mmLogout.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogout.defaultExpectation.params)
		}
	}

	return mmLogout
}

// Inspect accepts an inspector function that has same arguments as the Resolver.Logout
func (mmLogout *mResolverMockLogout) Inspect(f func(reqData proto.LogoutRequestData)) *mResolverMockLogout {
	if mmLogout.mock.inspectFuncLogout != nil {
		mmLogout.mock.t.Fatalf("Inspect function is already set for ResolverMock.Logout")
	}

	mmLogout.mock.inspectFuncLogout = f

	return mmLogout
}

// Return sets up results that will be returned by Resolver.Logout
func (mmLogout *mResolverMockLogout) Return(l1 proto.LoginResponseData, err error) *ResolverMock {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("ResolverMock.Logout mock is already set by Set")
	}

	if mmLogout.defaultExpectation == nil {
		mmLogout.defaultExpectation = &ResolverMockLogoutExpectation{mock: mmLogout.mock}
	}
	mmLogout.defaultExpectation.results = &ResolverMockLogoutResults{l1, err}
	return mmLogout.mock
}

// Set uses given function f to mock the Resolver.Logout method
func (mmLogout *mResolverMockLogout) Set(f func(reqData proto.LogoutRequestData) (l1 proto.LoginResponseData, err error)) *ResolverMock {
	if mmLogout.defaultExpectation != nil {
		mmLogout.mock.t.Fatalf("Default expectation is already set for the Resolver.Logout method")
	}

	if len(mmLogout.expectations) > 0 {
		mmLogout.mock.t.Fatalf("Some expectations are already set for the Resolver.Logout method")
	}

	mmLogout.mock.funcLogout = f
	return mmLogout.mock
}

// When sets expectation for the Resolver.Logout which will trigger the result defined by the following
// Then helper
func (mmLogout *mResolverMockLogout) When(reqData proto.LogoutRequestData) *ResolverMockLogoutExpectation {
	if mmLogout.mock.funcLogout != nil {
		mmLogout.mock.t.Fatalf("ResolverMock.Logout mock is already set by Set")
	}

	expectation := &ResolverMockLogoutExpectation{
		mock:   mmLogout.mock,
		params: &ResolverMockLogoutParams{reqData},
	}
	mmLogout.expectations = append(mmLogout.expectations, expectation)
	return expectation
}

// Then sets up Resolver.Logout return parameters for the expectation previously defined by the When method
func (e *ResolverMockLogoutExpectation) Then(l1 proto.LoginResponseData, err error) *ResolverMock {
	e.results = &ResolverMockLogoutResults{l1, err}
	return e.mock
}

// Logout implements Resolver
func (mmLogout *ResolverMock) Logout(reqData proto.LogoutRequestData) (l1 proto.LoginResponseData, err error) {
	mm_atomic.AddUint64(&mmLogout.beforeLogoutCounter, 1)
	defer mm_atomic.AddUint64(&mmLogout.afterLogoutCounter, 1)

	if mmLogout.inspectFuncLogout != nil {
		mmLogout.inspectFuncLogout(reqData)
	}

	mm_params := &ResolverMockLogoutParams{reqData}

	// Record call args
	mmLogout.LogoutMock.mutex.Lock()
	mmLogout.LogoutMock.callArgs = append(mmLogout.LogoutMock.callArgs, mm_params)
	mmLogout.LogoutMock.mutex.Unlock()

	for _, e := range mmLogout.LogoutMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.l1, e.results.err
		}
	}

	if mmLogout.LogoutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogout.LogoutMock.defaultExpectation.Counter, 1)
		mm_want := mmLogout.LogoutMock.defaultExpectation.params
		mm_got := ResolverMockLogoutParams{reqData}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogout.t.Errorf("ResolverMock.Logout got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogout.LogoutMock.defaultExpectation.results
		if mm_results == nil {
			mmLogout.t.Fatal("No results are set for the ResolverMock.Logout")
		}
		return (*mm_results).l1, (*mm_results).err
	}
	if mmLogout.funcLogout != nil {
		return mmLogout.funcLogout(reqData)
	}
	mmLogout.t.Fatalf("Unexpected call to ResolverMock.Logout. %v", reqData)
	return
}

// LogoutAfterCounter returns a count of finished ResolverMock.Logout invocations
func (mmLogout *ResolverMock) LogoutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogout.afterLogoutCounter)
}

// LogoutBeforeCounter returns a count of ResolverMock.Logout invocations
func (mmLogout *ResolverMock) LogoutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogout.beforeLogoutCounter)
}

// Calls returns a list of arguments used in each call to ResolverMock.Logout.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogout *mResolverMockLogout) Calls() []*ResolverMockLogoutParams {
	mmLogout.mutex.RLock()

	argCopy := make([]*ResolverMockLogoutParams, len(mmLogout.callArgs))
	copy(argCopy, mmLogout.callArgs)

	mmLogout.mutex.RUnlock()

	return argCopy
}

// MinimockLogoutDone returns true if the count of the Logout invocations corresponds
// the number of defined expectations
func (m *ResolverMock) MinimockLogoutDone() bool {
	for _, e := range m.LogoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogoutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogoutCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogout != nil && mm_atomic.LoadUint64(&m.afterLogoutCounter) < 1 {
		return false
	}
	return true
}

// MinimockLogoutInspect logs each unmet expectation
func (m *ResolverMock) MinimockLogoutInspect() {
	for _, e := range m.LogoutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ResolverMock.Logout with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LogoutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLogoutCounter) < 1 {
		if m.LogoutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ResolverMock.Logout")
		} else {
			m.t.Errorf("Expected call to ResolverMock.Logout with params: %#v", *m.LogoutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogout != nil && mm_atomic.LoadUint64(&m.afterLogoutCounter) < 1 {
		m.t.Error("Expected call to ResolverMock.Logout")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ResolverMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockLoginInspect()

		m.MinimockLogoutInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ResolverMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ResolverMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockLoginDone() &&
		m.MinimockLogoutDone()
}
